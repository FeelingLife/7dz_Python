# ШПАРГАЛКА ПО PYTHON

# 1 ЛЕКЦИЯ - Знакомство с языком программирования Python

# Расширение для Питона - .py

# Чтобы создать виртуальное окружение - terminal -- python3 -m venv .folder (Нажимаем ДА)

# Пустое значение - n = None

# Узнать какой тип данных используется - функция type:
# n = 5
# print(type(n))

# 'fd\'df' - чтобы внутри тоже поставить ковычку выводимую на экран

# # - комментирование строк одиночный вариант
# """ (...) """ - коммментирование от и до

# Чтобы сразу печатать значение переменных в выводе на экран:
# 1 враиант - print(f"{a} - {b} - {c}")
# 2 вариант - print("{} - {} - {}".format(a,b,c))

# input() - ввод данных
# input("Введите число") - сразу удобный способ написать и не выводить функцию print

# Если написать код:
# a = input()
# b = input()
# print(a, "-", b, "-", a + b)

# Выполнение программы будеь сумма строк - ab
# чтобы вывести число необходимо еще указать тип данных int:
# a = int(input())
# b = int(input())

# Основные арифметические операции:
# + - сложение
# - - вычитание
# * - умножение
# / - деление
# % - остаток
# // - целочисленное деление
# ** - возведение в степень

# Чтобы использовать округление нужна функция round:
# a = 1,34534534
# round(a, 3) - 1 аргумент - это число, 2 аргумент - знак после запятой, писать можно сразу так:
# print(round(a,3))

# Чтобы писать меньше код, используется следующий прием:
# += - ставим просто знак арифметической операции перед ровно и будет: аргумент = операция, аргумент

# Фукнкция if (...): - условие
# elif (...): - следующее условие
# else (...): - если условие не выполняется, то

# Логические операции and, or, not:
# and - Логическое "И"
# or - Логическое "ИЛИ"
# not - Логическое "НЕ РАВНО"

# Функция while (...): - цикл, выполянет код, пока условие верное (True)
# else (...): - если цикл не выполняется, то
# break - команда прерывания цикла - НЕЖЕЛАТЕЛЬНО
# Команду break заменяет метод флажка:

# n = int(input())
# flag = True
# i = 2
# while flag:
# 	if n % i == 0: # если остаток при делении числа n на i равен 0
# 		flag = False
# 		print(i)
# 	elif i > n // 2: # делить числа не может превышать введеное число, деленное на 2
# 		print(n)
# 		flag = False
# 	i += 1

# Цикл for в основном используется дял перебора значений: for (значение(обычно i)) in range()
# Вместе с циклом for можно использовать функцию range()
# range (a, b, c)m где:
# a - откуда начинаем перебор значений
# b - до какого значения производим перебор значений
# c - с каким шагом идет перебор значений (по умолчанию 1)
# если: 
# range (5) - начинается от 0 до конечного значения, то есть 5
# range (2, 5) - начинается от 2 до конечного значения, то есть 5
# range (0, -5) - ничего не будет выводиться, потому что шаг по умолчанию положительный
# range (1, 10, 2) - начинается от 2 до 10 с шагом 2, то есть будет 1, 3, 5, 7, 9
# range (100, 0, -20) - начинается от 100 до 0 с шагом 20, то есть 100, 80, 60, 40, 20

# Можно также работать со строками:

# a = "qwerty"

# print(a[0]) # Выведет первый элемент строки 

# for i in a:
# 	print(i) # Выведет все слово в стобец

# Есть функции, с которыми чаще всего работают:
# text = "Съешь еще этих мягких французких булок"
# ) print("еще" in text) - если слово "еще" в строке
# 1) Функция len(text) - выводит общее количество символов в переменной text
# 2) Функция lower(text) - перевод всех букв в нижний регистр
# 3) Функция upper(text) - перевод всех букв в верхний регистр
# 4) Функция text.replace("еще", "ЕЩЕ") - позволяет поменять сочетание символов в строке (Первое слово на второе во всем тексте переменной)

# Есть такое понятие срезы - 
# text = "Съешь еще этих мягких французких булок"
# 1) print(text[0]) - вывод нулевого элемента 
# 2) print(text[1]) - вывод первого элемента 
# 3) print(text[len(text)-1]) - вывод общей длины текста, но так как мы начинаем с нулевого, то чтобы нам вывести последнюю букву, нужно использовать -1 
# (фактически выдает значение, то есть считаем как обычно от 1 и до значения)
# print(text[-1]) - но можно сделать и иначе, через обратное индексирование (будет последняя буква)
# 4) print(text[-5]) - обратное индексирование, то есть пойдем с конца в начало и будет выведено последних 5 символов
# 5) print(text[:]) - вывод абсолютно всех символов
# 6) print(text[:2]) - вывести элементы с нулевого элемента и до 2, но 2 не включая
# 7) print(text[len(text)-2:]) - это мы вывводим 2 предпоследних значения (все)
# 8) print(text[2:9]) - диапазон который мы выводим
# 9) print(text[6:-18]) - Мы начинаем с 6 элемента и идем до обратного индексирования, до -18, иначе с 6 по 20
# 10) print(text[0:len(text):6]) - мы идем от 0 до конца строки с шагом 6, выводиться каждый 6 элемент
# 11) print(text[::6]) - 2 вариант воспроизведения 10 пункта (выше)
# 12) text = text[2:9] + text[-5] + text[:2] - складывание текста воедино, как пример


# 2 ЛЕКЦИЯ - Коллекция данных. Профилирование и отладка

# 1) Списки - это упорядоченный конечный набор элементов. Список - это массив, в котором можно хранить любые типы данных. list_1 - [] - запись
# list_1 - [] - запись или list_1 = list()

# list_1 = [1, 2, 3, 8]
# print(list_1) - вывод списка на экран - будет написано [1, 2, 3, 8], чтоб избавиться от скобок, пишем так - print(*list_1)

# Можно использовать цикл for и перебирать значения из списка:
# for i in range(list_1):
# 	print(i) # В стобик только будет - [1, 2 , 3, 8]

# Если работаем с массивами, то будь просто массив или список, при бращении к ячейке нумерация идет с 0. Если len() , то с 1.

# list_1 = [1, 5]
# print(list_1)

# Ниже будут представлены основные функции:
# 1) list_1.append() - добавляет значение в конец списка, причем берем доп. ячейку
# 2) list_1.pop() - удаление последнего элемента списка, и возвращает его в указанную переменную, например в А
#    list_1.pop(0) - удаление выбранного элемента, в моем случае 1 элемента
# 3) list_1.insert(2, 11) - добавляет элемент в список на нужную позицию. 2 - индекс позиции, 11 - какое число добавляем

# Срезы:
# list_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# 1) list_1[0] - вывод эемента
#    list_1[-1] - отрицательная индексация, будет отсчет с конца
#    list_1[:] - вывод всего списка. Если стоит перед : число то это откуда начинаем выводить, если после, то до куда
#    list_1[:2] - вывод с 1 до 2, 3 входит, но не выводится - правило листов
#    list_1[len(list_1)-2:] - берем длину списка, минусуем 2 и выводим последнее 2 элемента списка
#    list_1[2:9] - от 3 до 9 выводим
#    list_1[6:-18] - 
#    list_1[0:len(list_1):6] - идем с начала с шагом 6 по длине списка
#    list_1[::6] - упрощенная форма, выше написана развернутая форма

# 2) Кортеж - это неизменяемый список, нужны для защиты каких-либо данных от изменений. Кортеж занимает меньше места и памяти, работают быстрее
# по сравнению со списками.
# t = () - создание пустого кортежа
# print (type(t)) - вывод типа данных, в данном случае class tuple
# После того, как создается кортеж, необходимо оставить запятую ,
# t = (1, 5, 3,)
# Чтобы конвертировать список в кортеж, необходимо написать:
# v = [1, 8, 9]
# v = tuple(v)

# Множественное присваивание:
# a,b,c = 1,2,3

# a,b,c = v
# print(a, b, c) - распаковка кортежа по переменным

# 3) Словари - неупорядоченные коллекции произвольных объектов с доступом по ключу.
# В списках в качестве ключа используется индекс элемента. В словаре используется схема (строка, число)
# d = {} или d = dict{} - создание пустого словаря

# d["q"] (ключ) = "qwerty" (значение) - отображение {"q" : "qwerty"}, при вызове q мы получать значение qwerty - это идет заполнение словаря d
# del d["q"] - удаление ключа
# item - вывод всех ключей из словаря
# print('{}: {}'.format(item, d[item]))
# k, v - ключ и значение, это для упрощения
# dictionary.items() - вывод кортежа, где идет ключ и значение

# 4) Множества - содержат в себе уникальные элементы, не обязательно упорядоченные.
# Одно множество может содержать значения любых типов. Если у Вас есть два множества,

# colors = {"red", "blue", "green"}

# Функция .add - можно добавлять значение, добавляет по своему алгоритму
# Функция .remove - можно удалять значение, но если этого значения и так нет, то будет ошибка
# Функция .discard - проверячет есть ли в множестве и если есть удалчет, если нет, то ничего не происходит
# Функция .clear - удалить все элементы и итог на выводе будет set()

# Вы можете совершать над ними любые стандартные операции, например, объединение, пересечение и разность.

# a = {1, 2, 3, 5, 8}
# b = {2, 5, 8, 13, 21}
# c = a.copy() - копирование множества
# u = a.union(b) - объединение уникальных значений
# i = a.intersection(b) - вывод уникальных элементов, которые есть и в а, и в b
# d1 = a.difference(b) - вычитание, только уникальные значения в а, которых нет в b
# dr = b.difference(a) - вычитание, только уникальные значения в b, которых нет в a
# q = a.union(b).difference(a.intersection(b)) - первое действие в скобках, и потом идем по порядку, и у нас получается:
# Мы ищем уникальные значения и в a, и в b, далее a объединяем с b и находим разность с множеством, которое в скобках

# frozenset() - змароженное множество - не можем его изменять

# 3 ЛЕКЦИЯ - Функция, рекурсия, алгоритмы

# 1) Функция - фрагмент программы, используемный многократно.

# def function_name(x):	- как записывается
# 	body line 1
# 		# ...
# 	body kine n
# 	optional return

# Пример:
# def sum_numbers(n)
# 	summa = 0
# 	for i in range(n+1)
# 		summa += i
# 	print(summa)
# sum_numbers(5)

# другая концовка:
# ...
# for i in range(n+1)
# 	summa += i
# return summa
# print(sum_numbers(5))

# Пример программы для принятия неограниченного количества аргументов:
# def sum_str(*args)
# 	res = ""
# 	for i in args:
# 		res += i
# 	return res
# print(sum_str("q", "w", "i"))

# 2) Модульность - написанные функции, которые хранятся в модулях, и мыф прост опользуемся ими и вызываем.

# def max1 (a, b):		- создали отдельный файл и написали в нем функцию
# 	if a > b:
# 		return a
# 	return b

# Вызываем функцию из другого файла:
# 1 вариант:

# import modul1 (название файла)
# print(modul1.max1(5,9))

# 2 вариант (импорт напрямую):

# from modul1 import max1
# print(max1(10, 9))

# from modul1 as m1	- переназвание программы в текущем файле откуда импорт (если например длинное название)
# print(m1.max1(15,29))

# from modul1 import *	- импорт всех функций из файла

# 3) Рекурсия - это функция, которая вызываем сама себя.

# Число последовательности Фибоначчи:

# def fib(n):
# 	if n in [1,2]:
# 		return 1
# 	return fib(n-1) + fib(n-2)

# list_1 = []
# for i in range(1, 10):
# 	list_1.append(fib(i))
# print(list_1)

# 4) Алгоритмы - набор инструкций для выполнения некоторой задачи.

# 1.1 Быстрая сортировка - стратегия "Разделяй и властвуй":

# def quick_sort(array):
# 	if len(array) <= 1
# 		return array
# 	else:
# 		pivot = array[0]
# 	less = [i for i in array[1:] if i <= pivot]
# 	greater = [i for i in array[1:] if i > pivot]
# 	return quick_sort(less) + [pivot] + quick_sort(greater)

# print(quick_sort(14,2,43,1,55,5,2))

# 1.2 Сортировка слиянием - делим до тех пор, пока не будет по 1 элементу, потом соединяем упорядочивая по возрастанию.

# def merge_sort(nums):
# 	if len(nums) > 1:
# 		mid = len(nums) // 2
# 		left = nums[:mid]
# 		right = nums[mid:]
# 		merge_sort(left)
# 		merge_sort(right)
# 		i = j = k = 0
# 		while i < len(left) and j < len(right)
# 			if left[i] < right[j]
# 				nums[k] - left[i]
# 				i += 1
# 			else:
# 				num[k] = right[j]
# 				j += 1
# 			k += 1
# 		while i < len(left) and j < len(right)
# 			if left[i] < right[j]
# 				nums[k] - left[i]
# 				i += 1
# 			else:
# 				num[k] = right[j]
# 				j += 1
# 			k += 1

# 		while i < len(left):
# 			nums[k] = left[i]
# 			i += 1
# 			k += 1

# 		while j < len(right):
# 			nums[k] = right[j]
# 			j += 1
# 			k += 1

# list1 = [3,5,2,4,5,2,234,23]
# merge_sort(list1)
# print(list1)

# 4 ЛЕКЦИЯ: Функции высшего порядка, работа с файлами

# 1) def calk1(a):		- функция, которая возвращает сумму А
# 	return a+a
#    def calk2(a):		- функция, которая возвращает перемножение А
# 	return a*a


#    def math(op, x)
# 	print(op(x)) - op функция, которая будет принимать значения обозначенной функции выше (1 из 2) внутри

#    calk1 = lambda a, b: a + b - вводим элементы а и b, двоеточие разграничивает и показывает что планируется с ними делать (все это упрощение функций выше)
#    Чтобы еще упростить, можно добавить прям вместо op:

#    math(lambda a,b: a+b, 5, 45)

# 2) def select(f, col)
# 	return [f(x) for x in col]

#    def where(f, col)
# 	return [x for x in col if f(x)]

#    data = [1, 2, 3, 5, 7, 12, 36]
#    res = select(int, d)
#    res = where(lambda x: x % 2 == 0, res)
#    res = list(select(lambda x: (x, x**2), res))
#    print(res)

# 3) Функция map - Функция map() применяет указанную функцию к каждому элементу итерируемого объекта и возвращает итератор с новыми объектами.

#    list_1 = [1, 2, 3, 4, 5, 6]
#    list_1 = list(map(lambda x: x + 10, list_1)) - lambda x: x + 10 - функция которую мы хотим применить к каждому объекту и 
#    						  list_1 - объект, к котормоу мы применяем
#    print(list_1)

#    функция строка.split() - убирает все пробелы и создаем список из значений строки

#    data = '1 2 3 5 8 15 23 38'.split()
#    print(data) # ['1', '2', '3', '5', '8', '15', '23', '38']

#    data = '15 156 98 4 1 78'
#    data = list(map(int, data.split()))

#    Результат работы map() — это итератор. По итератору можно пробежаться только один раз. Чтобы
#    работать несколько раз с одними данными, нужно сохранить данные (например, в виде списка).
#    Как можно сделать этот код лучше, используя map()?
#    map() позволит избавиться от функции select.

#    def where(f, col):
#      return [x for x in col if f(x)]
#    data = '1 2 3 5 8 15 23 38'.split()
#    res = map(int, data)
#    res = where(lambda x: x % 2 == 0, res)
#    res = list(map(lambda x: (x, x ** 2), res))
#    print(res)


# 4) Функция filter - применяет указанную функцию к каждому элементу итерируемого объекта и возвращает итератор с теми объектами, 
#    для которых функция вернула True.
#    Как в данном случае работает функция filter()? Все данные, которые находятся внутри проходят
#    через функцию, которая указана следующим образом:
#    lambda x: x % 2 == 0
#    То есть делает проверка на те числа, которые при делении на 2 дают в остатке 0. Тем самым мы
#    ищем только четные числа. Действительно преобразовав наши итоговые данные в список, с
#    помощью функции list().

#    data = [15, 65, 9, 36, 45]
#    res = list_1(filter(lambda x: x % 10 == 5, data))
#    print(res)

# 5) Функция zip - Функция zip() применяется к набору итерируемых объектов и возвращает итератор с кортежами из элементов входных данных
#    zip ([1, 2, 3], ['о', 'т', 'д'], ['f', 's', 'h'])
#    [(1, 'о', 'f'), (2, 'т', 's'), (3, 'д', 'h'),]

#    Пример:
#    users = ['user1', 'user2', 'user3', 'user4', 'user5']
#    ids = [4, 5, 9, 14, 7]
#    data = list(zip(users, ids))
#    print(data) # [('user1', 4), ('user2', 5), ('user3', 9), ('user4', 14), ('user5', 7)]

#    Функция zip () пробегает по минимальному входящему набору:
#    users = ['user1', 'user2', 'user3', 'user4', 'user5']
#    ids = [4, 5, 9, 14, 7]
#    salary = [111, 222, 333]
#    data = list(zip(users, ids, salary))
#    print(data) # [('user1', 4, 111), ('user2', 5, 222), ('user3', 333)]

# 6) Функция enumerate - Функция enumerate() применяется к итерируемому объекту и возвращает новый итератор с кортежами из индекса и элементов входных данных.
   
#    enumerate(['Казань', 'Смоленск', 'Рыбки', 'Чикаго'])
#    [(0, 'Казань'), (1, 'Смоленск'), (2, 'Рыбки'), (3, 'Чикаго')]
   
#    Функция enumerate() позволяет пронумеровать набор данных.
#    users = ['user1', 'user2', 'user3']
#    data = list(enumerate(users)
#    print(data) # [(0, 'user1'), (1, 'user2'), (2, 'user3))]

# 7) Функция count - подсчет сколько встречается число или буква в списке
#    Использование метода count() в списках:

#    my_list = [1, 2, 3, 4, 4, 5, 4]
#    count_of_fours = my_list.count(4)
#    print(count_of_fours)
#    # Итого - 3

#    Результат выполнения этого кода будет равен «3», потому что в списке три элемента со значением «4».



#     ФАЙЛЫ	

#    Файлы в текстовом формате используются для:
#    ● Хранения данных
#    ● Передачи данных в клиент-серверных проектах
#    ● Хранения конфигов
#    ● Логирования действий

#    Что нужно для работы с файлами:
#    1. Завести переменную, которая будет связана с этим текстовым файлом.
#    2. Указать путь к файлу.
#    3. Указать, в каком режиме мы будем работать с файлом.

#    Варианты режима (мод):
#    a – открытие для добавления данных.
#    ○ Позволяет дописывать что-то в имеющийся файл.
#    ○ Если вы попробуете дописать что-то в несуществующий файл, то файл будет создан и в него начнется запись.

#    r – открытие для чтения данных.
#    ○ Позволяет читать данные из файла.
#    ○ Если вы попробуете считать данные из файла, которого не существует, программа выдаст ошибку.

#    w – открытие для записи данных
#    ○ Позволяет записывать данные и создавать файл, если его не существует.

#    Миксованные режимы:
#    1. w+
#    ○ Позволяет открывать файл для записи и читать из него.
#    ○ Если файла не существует, он будет создан.

#    2. r+
#    ○ Позволяет открывать файл для чтения и дописывать в него.
#    ○ Если файла не существует, программа выдаст ошибку.

#    Примеры использования различных режимов в коде:
#    1. Режим a
#    colors = ['red', 'green', 'blue']
#    data = open('file.txt', 'a') # здесь указываем режим, в котором будем работать
#    data.writelines(colors) # разделителей не будет
#    data.close()
#    ● data.close() — используется для закрытия файла, чтобы разорвать подключение файловой переменной с файлом на диске.
#    ● exit() — позволяет не выполнять код, прописанный после этой команды в скрипте.
#    ● В итоге создаётся текстовый файл с текстом внутри: redbluedreen.
#    ● При повторном выполнении скрипта redbluedreenredbluedreen — добавление в существующий файл, а не перезапись файлов.

#    Ещё один способ записи данных в файл:
#    with open('file.txt', 'w') as data:
#      data.write('line 1\n')
#      data.write('line 2\n')

#    2. Режим r
#    ● Чтение данных из файла:
#    path = 'file.txt'
#    data = open(path, 'r')
#    for line in data:
#      print(line)
#    data.close()

#    3. Режим w
#      colors = ['red', 'green', 'blue']
#      data = open('file.txt', 'w')
#      data.writelines(colors) # разделителей не будет
#      data.close()

#    ● В итоге создаётся текстовый файл с текстом внутри: ‘redbluedreen’.
#    ● В случае перезаписи новые данные записываются, а старые удаляются.



#    МОДУЛЬ OS

#    Модуль os предоставляет множество функций для работы с операционной системой, причем ихповедение, как правило, не зависит от ОС, 
#    поэтому программы остаются переносимыми.
#    Для того, чтобы начать работать с данным модулем необходимо его импортировать в свою программу: import os

#    Познакомимся с базовыми функциями данного модуля:
#    ● os.chdir(path) - смена текущей директории.  
#    import os
#    os.chdir('C:/Users/79190/PycharmProjects/GB')

#    ● os.getcwd() - текущая рабочая директория
#    import os
#    print(os.getcwd()) # 'C:\Users\79190\PycharmProjects\webproject'

#    ● os.path - является вложенным модулем в модуль os и реализует некоторые полезные функции для работы с путями, такие как:
#       ○ os.path.basename(path) - базовое имя пути
#       import os
#       print(os.path.basename('C:/Users/79190/PycharmProjects/webproject/main.py')) #'main.py'

#    ● os.path.abspath(path) - возвращает нормализованный абсолютный путь.
#    import os
#    print(os.path.abspath('main.py')) # 'C:/Users/79190/PycharmProjects/webproject/main.py'



#    МОДУЛЬ SHUTIL

#    Модуль shutil содержит набор функций высокого уровня для обработки файлов, групп файлов, и папок. В частности,
#    доступные здесь функции позволяют копировать, перемещать и удалять файлы и папки. Часто используется вместе с модулем os.
#    Для того, чтобы начать работать с данным модулем необходимо его импортировать в свою программу:
#    import shutil

#    Базовыми функции данного модуля:
#    ● shutil.copyfile(src, dst) - копирует содержимое (но не метаданные) файла src в файл dst.
#    ● shutil.copy(src, dst) - копирует содержимое файла src в файл или папку dst.
#    ● shutil.rmtree(path) - Удаляет текущую директорию и все поддиректории; path должен указывать на директорию, а не на символическую ссылку
